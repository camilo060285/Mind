"""Repository manager for autonomous system creation.

Handles Git repository initialization, structure setup, and metadata
for systems generated by Mind. Each generated system gets its own
independent repository.
"""

import json
import subprocess
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional

from ..utils.logger import get_logger
from .system_spec import SystemSpec

logger = get_logger(__name__)


class RepositoryInitializer:
    """Initializes Git repositories for generated systems."""

    def __init__(self, parent_dir: Optional[Path] = None):
        """Initialize repository manager.

        Args:
            parent_dir: Parent directory for system repos
                       (default: ~/.mind_systems)
        """
        if parent_dir is None:
            parent_dir = Path.home() / ".mind_systems"

        self.parent_dir = Path(parent_dir)
        self.parent_dir.mkdir(parents=True, exist_ok=True)
        logger.info(f"RepositoryInitializer initialized: {self.parent_dir}")

    def create_system_repository(
        self,
        system_name: str,
        system_id: str,
        spec: SystemSpec,
        system_type: str = "agent-cluster",
    ) -> Dict[str, Any]:
        """Create a complete Git repository for a generated system.

        Args:
            system_name: Name of the system (lowercase, no spaces)
            system_id: Unique system identifier
            spec: System specification
            system_type: Type of system (agent-cluster, subsystem, orchestrator, etc.)

        Returns:
            Dictionary with repo creation details
        """
        # Create repo directory
        repo_path = self.parent_dir / f"{system_name}_{system_id}"
        repo_path.mkdir(parents=True, exist_ok=True)

        logger.info(f"Creating repository: {repo_path}")

        try:
            # Initialize Git repo
            self._init_git_repo(repo_path)

            # Create directory structure
            self._create_structure(repo_path)

            # Generate .gitignore
            self._create_gitignore(repo_path, system_type)

            # Generate README
            readme_path = self._create_readme(repo_path, system_name, spec)

            # Create system metadata
            self._create_metadata(
                repo_path,
                system_name,
                system_id,
                spec,
                system_type,
            )

            # Create initial commit
            commit_hash = self._create_initial_commit(repo_path, system_name, system_id)

            # Initialize branches
            self._setup_branches(repo_path)

            logger.info(f"Repository created successfully: {repo_path}")

            return {
                "repo_path": str(repo_path),
                "repo_url": str(repo_path),  # Local path as URL
                "system_id": system_id,
                "system_name": system_name,
                "system_type": system_type,
                "created_at": datetime.now().isoformat(),
                "initial_commit": commit_hash,
                "readme_path": str(readme_path),
                "metadata_path": str(repo_path / "system.metadata.json"),
                "branches": ["main", "dev"],
                "status": "ready",
            }

        except Exception as e:
            logger.error(f"Failed to create repository: {e}")
            raise

    def _init_git_repo(self, repo_path: Path) -> None:
        """Initialize Git repository."""
        try:
            subprocess.run(
                ["git", "init"],
                cwd=repo_path,
                check=True,
                capture_output=True,
            )
            logger.debug(f"Git repository initialized: {repo_path}")

            # Configure Git (use system git config if available, otherwise local)
            subprocess.run(
                ["git", "config", "user.email", "system@mind.local"],
                cwd=repo_path,
                check=True,
                capture_output=True,
            )
            subprocess.run(
                ["git", "config", "user.name", "Mind System Generator"],
                cwd=repo_path,
                check=True,
                capture_output=True,
            )
        except subprocess.CalledProcessError as e:
            logger.error(f"Git initialization failed: {e}")
            raise

    def _create_structure(self, repo_path: Path) -> None:
        """Create standard directory structure for generated system."""
        dirs = [
            "agents",
            "models",
            "blueprints",
            "core",
            "tests",
            "data",
            "config",
            "scripts",
            "docs",
        ]
        for d in dirs:
            (repo_path / d).mkdir(parents=True, exist_ok=True)

        # Create __init__.py files
        (repo_path / "agents" / "__init__.py").touch()
        (repo_path / "models" / "__init__.py").touch()
        (repo_path / "core" / "__init__.py").touch()
        (repo_path / "tests" / "__init__.py").touch()

        logger.debug(f"Directory structure created: {repo_path}")

    def _create_gitignore(self, repo_path: Path, system_type: str) -> None:
        """Generate appropriate .gitignore file.

        Args:
            repo_path: Repository root path
            system_type: Type of system for appropriate patterns
        """
        gitignore_content = """# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
venv/
ENV/
env/
.venv

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.DS_Store

# Environment variables
.env
.env.local

# Runtime data
data/
logs/
*.log

# System-specific
.mind_cache/
.system_state
*.tmp

# Dependencies
node_modules/
package-lock.json

# Testing
.pytest_cache/
.coverage
htmlcov/

# Documentation build
docs/_build/
"""
        gitignore_path = repo_path / ".gitignore"
        gitignore_path.write_text(gitignore_content)
        logger.debug(f"Gitignore created: {gitignore_path}")

    def _create_readme(
        self, repo_path: Path, system_name: str, spec: SystemSpec
    ) -> Path:
        """Generate comprehensive README for the system.

        Args:
            repo_path: Repository root path
            system_name: System name
            spec: System specification

        Returns:
            Path to generated README
        """
        components_list = "\n".join(
            [
                f"- **{c.name}** ({c.role.value}): {c.description}"
                for c in spec.components
            ]
        )

        features_list = "\n".join([f"- {f}" for f in spec.features])
        tools_list = "\n".join([f"- {t}" for t in spec.tools])

        readme_content = f"""# {system_name.replace('_', ' ').title()}

**Status**: Autonomously generated by Mind

## Overview

**Goal**: {spec.goal}

**Description**: {spec.description}

**System Type**: Generated autonomous agent cluster  
**Generated By**: Mind Meta-System  
**Independent Repository**: This repository is completely independent from Mind

---

## âœ¨ Features

{features_list if spec.features else '- Core functionality'}

---

## ðŸ”§ Components

{components_list}

---

## ðŸ› ï¸ Tools & Integrations

{tools_list if spec.tools else '- No external tools configured'}

---

## ðŸ“ Project Structure

```
{system_name}/
â”œâ”€â”€ agents/              # Agent implementations
â”œâ”€â”€ models/              # Data models and schemas
â”œâ”€â”€ blueprints/          # Workflow definitions (YAML)
â”œâ”€â”€ core/                # Core orchestration logic
â”œâ”€â”€ tests/               # Test suite
â”œâ”€â”€ data/                # Runtime data and assets
â”œâ”€â”€ config/              # System configuration
â”œâ”€â”€ scripts/             # Utility scripts
â”œâ”€â”€ docs/                # Documentation
â”œâ”€â”€ system.metadata.json # System metadata
â””â”€â”€ README.md            # This file
```

---

## ðŸš€ Getting Started

### Prerequisites

- Python 3.10+
- Git (optional, for version control)

### Installation

1. Clone/pull this repository:
   ```bash
   cd {system_name}_{spec.config.get('system_id', 'XXXX')}
   ```

2. Create virtual environment:
   ```bash
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\\Scripts\\activate
   ```

3. Install dependencies:
   ```bash
   pip install -r requirements.txt
   ```

### Running the System

```bash
python cli.py
```

---

## ðŸ—ï¸ Architecture

This system was **generated autonomously** by Mind's SystemGenerator. The architecture is designed to be:

- **Modular**: Each component operates independently
- **Extensible**: Easy to add new agents, workflows, or tools
- **Scalable**: Multi-agent coordination with clear boundaries
- **Observable**: Built-in logging and monitoring

### Core Workflows

See `blueprints/` for YAML-based workflow definitions.

---

## ðŸ”„ Integration

### Adding New Agents

1. Create new agent in `agents/{{agent_name}}.py`
2. Register in `core/orchestrator.py`
3. Define workflow steps in `blueprints/`
4. Add tests in `tests/test_{{agent_name}}.py`

### Adding External Tools

1. Create tool wrapper in `agents/tools/`
2. Register with system configuration
3. Define inputs/outputs in `config/`
4. Update blueprints to use tool

### Modifying Workflows

Edit YAML files in `blueprints/` to adjust system behavior.

---

## ðŸ“Š Monitoring

The system includes built-in monitoring:

```bash
python scripts/monitor.py
```

---

## ðŸ§ª Testing

Run test suite:

```bash
pytest tests/
```

---

## ðŸ“ System Metadata

System creation and configuration details are stored in `system.metadata.json`.

This file contains:
- System ID and name
- Creation timestamp
- Mind version used
- System specification
- Dependencies

---

## ðŸ” Independence & Sovereignty

This repository is **fully independent** from Mind. You can:

- Fork and modify without affecting Mind
- Deploy to production independently
- Maintain separate version history
- Control all code and dependencies

Mind only stores a reference to this repository in its registry.

---

## ðŸ“ž Support & Extension

To extend this system:

1. Review the architecture documentation
2. Check examples in `agents/` and `blueprints/`
3. Modify configuration in `config/`
4. Add new components following the same patterns

---

## ðŸ”— Relationship to Mind

This system was created by Mind but operates independently:

- **Mind's Role**: Created the initial structure and orchestration
- **Your Role**: Customize, extend, and deploy this system
- **Repository**: This repo is yours to control completely

To update this system in the future:
- Make changes locally in this repository
- Commit to appropriate branch (main/dev)
- Mind can reference your changes via the registry

---

**Generated**: {datetime.now().isoformat()}  
**System ID**: {spec.config.get('system_id', 'N/A')}  
**Mind Version**: {spec.config.get('mind_version', 'N/A')}
"""

        readme_path = repo_path / "README.md"
        readme_path.write_text(readme_content)
        logger.debug(f"README created: {readme_path}")
        return readme_path

    def _create_metadata(
        self,
        repo_path: Path,
        system_name: str,
        system_id: str,
        spec: SystemSpec,
        system_type: str,
    ) -> Dict[str, Any]:
        """Create system metadata file.

        Args:
            repo_path: Repository root path
            system_name: System name
            system_id: System ID
            spec: System specification
            system_type: Type of system

        Returns:
            Metadata dictionary
        """
        from ..core.identity import MindIdentity

        mind_identity = MindIdentity()
        mind_version = mind_identity.version

        metadata = {
            "system": {
                "id": system_id,
                "name": system_name,
                "type": system_type,
                "created_at": datetime.now().isoformat(),
            },
            "generation": {
                "mind_version": mind_version,
                "mind_name": mind_identity.name,
                "generated_at": datetime.now().isoformat(),
            },
            "specification": spec.to_dict(),
            "repository": {
                "path": str(repo_path),
                "type": "git",
                "branches": ["main", "dev"],
            },
            "dependencies": {
                "python": "3.10+",
                "external": spec.tools,
            },
        }

        metadata_path = repo_path / "system.metadata.json"
        with open(metadata_path, "w") as f:
            json.dump(metadata, f, indent=2)

        logger.debug(f"Metadata created: {metadata_path}")
        return metadata

    def _create_initial_commit(
        self, repo_path: Path, system_name: str, system_id: str
    ) -> str:
        """Create initial Git commit.

        Args:
            repo_path: Repository root path
            system_name: System name
            system_id: System ID

        Returns:
            Commit hash
        """
        try:
            # Add all files
            subprocess.run(
                ["git", "add", "."],
                cwd=repo_path,
                check=True,
                capture_output=True,
            )

            # Create commit
            commit_message = (
                f"Initial commit: {system_name} (ID: {system_id})\n\n"
                "Generated autonomously by Mind SystemGenerator.\n"
                "This repository is now independent and can be managed separately."
            )

            subprocess.run(
                ["git", "commit", "-m", commit_message],
                cwd=repo_path,
                check=True,
                capture_output=True,
            )

            # Get commit hash
            result = subprocess.run(
                ["git", "rev-parse", "HEAD"],
                cwd=repo_path,
                check=True,
                capture_output=True,
                text=True,
            )
            commit_hash = result.stdout.strip()

            logger.debug(f"Initial commit created: {commit_hash}")
            return commit_hash

        except subprocess.CalledProcessError as e:
            logger.error(f"Commit creation failed: {e}")
            raise

    def _setup_branches(self, repo_path: Path) -> None:
        """Set up main and dev branches.

        Args:
            repo_path: Repository root path
        """
        try:
            # Rename initial branch to main if needed
            subprocess.run(
                ["git", "branch", "-M", "main"],
                cwd=repo_path,
                check=True,
                capture_output=True,
            )

            # Create dev branch from main
            subprocess.run(
                ["git", "checkout", "-b", "dev"],
                cwd=repo_path,
                check=True,
                capture_output=True,
            )

            # Switch back to main
            subprocess.run(
                ["git", "checkout", "main"],
                cwd=repo_path,
                check=True,
                capture_output=True,
            )

            logger.debug("Branches initialized: main, dev")

        except subprocess.CalledProcessError as e:
            logger.error(f"Branch setup failed: {e}")
            raise
